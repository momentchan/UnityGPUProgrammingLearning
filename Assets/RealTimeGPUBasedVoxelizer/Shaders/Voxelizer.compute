#pragma kernel SurfaceFront
#pragma kernel SurfaceBack
#pragma kernel Volume

#include "UnityCG.cginc"
#include "Structure/Voxel.cginc"

float3 _Start, _End, _Size;
float _Unit, _InvUnit, _HalfUnit;
int _Width, _Height, _Depth;

StructuredBuffer<float3> _VertBuffer;
StructuredBuffer<int> _TriBuffer;
int _TriangleCount;

RWStructuredBuffer<Voxel> _VoxelBuffer;

struct AABB {
	float3 min, max, center;
};

struct Plane {
	float3 normal;
	float distance;
};

void get_triangle(int idx, out float3 va, out float3 vb, out float3 vc, out bool front) {

	int ia = _TriBuffer[idx * 3];
	int ib = _TriBuffer[idx * 3 + 1];
	int ic = _TriBuffer[idx * 3 + 2];

	va = _VertBuffer[ia];
	vb = _VertBuffer[ib];
	vc = _VertBuffer[ic];

	float3 normal = cross(vb - va, vc - va);
	front = dot(normal, float3(0, 0, 1)) < 0;
}

int get_voxel_index(int x, int y, int z) {
	return z * (_Width * _Height) + y * _Width + x;
}

float3 get_voxel_position(int x, int y, int z) {
	return float3(x, y, z) * _Unit + _Start + float3(_HalfUnit, _HalfUnit, _HalfUnit);
}

bool intersects_tri_aabb_onto_axis(float3 v0, float3 v1, float3 v2, float3 extents, float3 axis) {
	// project triangles
	float p0 = dot(v0, axis);
	float p1 = dot(v1, axis);
	float p2 = dot(v2, axis);

	// project aabb
	float r = extents.x * abs(axis.x) + extents.y * abs(axis.y) + extents.z * abs(axis.z);
	float minP = min(p0, min(p1, p2));
	float maxP = max(p0, max(p1, p2));
	return !(maxP < -r || r < minP);
}

bool intersects_plane_aabb(Plane pl, AABB aabb) {
	float3 center = aabb.center;
	float3 extents = aabb.max - center;

	float r = extents.x * abs(pl.normal.x) + extents.y * abs(pl.normal.y) + extents.z * abs(pl.normal.z);
	float s = dot(pl.normal, center) - pl.distance;

	return abs(s) <= r;
}
bool intersects_tri_aabb(float3 va, float3 vb, float3 vc, AABB aabb) {
	float3 center = aabb.center, extents = aabb.max - center;

	// Translate triange
	float3 v0 = va - center,
		   v1 = vb - center,
		   v2 = vc - center;

	// Edge vectors
	float3 e0 = v1 - v0,
		   e1 = v0 - v2,
		   e2 = v2 - v1;

	// cross products of triangle edges & aabb edges
	// AABB normals are the x (1, 0, 0), y (0, 1, 0), z (0, 0, 1) axis.
	// so we can get the cross products between triangle edge vectors and AABB normals without calculation
	float3 a00 = float3(0, -e0.z, e0.y), // cross product of X and e0
		   a01 = float3(0, -e1.z, e1.y), // X and e1
		   a02 = float3(0, -e2.z, e2.y), // X and e2
		   a10 = float3(e0.z, 0, -e0.x), // Y and e0
		   a11 = float3(e1.z, 0, -e1.x), // Y and e1
		   a12 = float3(e2.z, 0, -e2.x), // Y and e2
		   a20 = float3(-e0.y, e0.x, 0), // Z and e0
		   a21 = float3(-e1.y, e1.x, 0), // Z and e1
		   a22 = float3(-e2.y, e2.x, 0); // Z and e2

	// Test 9 axis
	if (
		!intersects_tri_aabb_onto_axis(v0, v1, v2, extents, a00) ||
		!intersects_tri_aabb_onto_axis(v0, v1, v2, extents, a01) ||
		!intersects_tri_aabb_onto_axis(v0, v1, v2, extents, a02) ||
		!intersects_tri_aabb_onto_axis(v0, v1, v2, extents, a10) ||
		!intersects_tri_aabb_onto_axis(v0, v1, v2, extents, a11) ||
		!intersects_tri_aabb_onto_axis(v0, v1, v2, extents, a12) ||
		!intersects_tri_aabb_onto_axis(v0, v1, v2, extents, a20) ||
		!intersects_tri_aabb_onto_axis(v0, v1, v2, extents, a21) ||
		!intersects_tri_aabb_onto_axis(v0, v1, v2, extents, a22)
	) {
		return false;
	}

	// Test X axis
	if (max(v0.x, max(v1.x, v2.x)) < -extents.x || extents.x < min(v0.x, min(v1.x, v2.x)))
		return false;
	// Test Y axis
	if (max(v0.y, max(v1.y, v2.y)) < -extents.y || extents.y < min(v0.y, min(v1.y, v2.y)))
		return false;
	// Test Z axis
	if (max(v0.z, max(v1.z, v2.z)) < -extents.z || extents.z < min(v0.z, min(v1.z, v2.z)))
		return false;

	// test triangle normal
	Plane pl;
	pl.normal = normalize(cross(e1, e0));
	pl.distance = dot(pl.normal, va);
	return intersects_plane_aabb(pl, aabb);
}


void surface(float3 va, float3 vb, float3 vc, bool front) {

	// triangle aabb
	float3 tbmin = min(min(va, vb), vc);
	float3 tbmax = max(max(va, vb), vc);

	float3 bmin = tbmin - _Start;
	float3 bmax = tbmax - _Start;
	int iminX = round(bmin.x / _Unit);
	int iminY = round(bmin.y / _Unit);
	int iminZ = round(bmin.z / _Unit);
	int imaxX = round(bmax.x / _Unit);
	int imaxY = round(bmax.y / _Unit);
	int imaxZ = round(bmax.z / _Unit);

	iminX = clamp(iminX, 0, _Width - 1);
	iminY = clamp(iminY, 0, _Height - 1);
	iminZ = clamp(iminZ, 0, _Depth - 1);
	imaxX = clamp(imaxX, 0, _Width - 1);
	imaxY = clamp(imaxY, 0, _Height - 1);
	imaxZ = clamp(imaxZ, 0, _Depth - 1);

	// Intersection Check
	for (int x = iminX; x <= imaxX; x++) {
		for (int y = iminY; y <= imaxY; y++) {
			for (int z = iminZ; z <= imaxZ; z++) {
				float3 center = float3(x, y, z) * _Unit + _Start;
				AABB aabb;
				aabb.min = center - _HalfUnit;
				aabb.center = center;
				aabb.max = center + _HalfUnit;
				if (intersects_tri_aabb(va, vb, vc, aabb)) {
					uint vid = get_voxel_index(x, y, z);
					Voxel voxel = _VoxelBuffer[vid];
					voxel.position = center;
					voxel.front = front;
					voxel.fill = true;
					_VoxelBuffer[vid] = voxel;
				}
			}
		}
	}
}

[numthreads(8,8,1)]
void SurfaceFront(uint3 id : SV_DispatchThreadID)
{
	int idx = (int)id.x;
	if (idx >= _TriangleCount) return;

	float3 va, vb, vc;
	bool front;
	get_triangle(idx, va, vb, vc, front);

	if (!front) return;

	surface(va, vb, vc, front);
}

[numthreads(8, 8, 1)]
void SurfaceBack(uint3 id : SV_DispatchThreadID)
{
	int idx = (int)id.x;
	if (idx >= _TriangleCount) return;

	float3 va, vb, vc;
	bool front;
	get_triangle(idx, va, vb, vc, front);

	if (front) return;

	surface(va, vb, vc, front);
}

[numthreads(8, 8, 1)]
void Volume(uint3 id : SV_DispatchThreadID)
{
	int x = (int)id.x;
	int y = (int)id.y;
	if (x >= _Width) return;
	if (y >= _Height) return;

	for (int z = 0; z < _Depth; z++) {
		Voxel voxel = _VoxelBuffer[get_voxel_index(x, y, z)];

		if (is_empty_voxel(voxel)) continue;

		// Find front index
		int ifront = z;
		for (; ifront < _Depth && is_front_face(_VoxelBuffer[get_voxel_index(x, y, ifront)]); ifront++) {}
		if (ifront >= _Depth) break;

		// Find back index
		int iback = ifront;
		for (; iback < _Depth && is_empty_voxel(_VoxelBuffer[get_voxel_index(x, y, iback)]); iback++) {}

		if (iback >= _Depth) break;

		if (is_back_face(_VoxelBuffer[get_voxel_index(x, y, iback)])) {
			for (; iback < _Depth && is_back_face(_VoxelBuffer[x, y, iback]); iback++) {}
		}

		for (int z2 = ifront; z2 < iback; z2++) {
			Voxel v;
			v.position = get_voxel_position(x, y, z2);
			v.fill = true;
			v.front = false;
			_VoxelBuffer[get_voxel_index(x, y, z2)] = v;
		}
		z = iback;
	}
}