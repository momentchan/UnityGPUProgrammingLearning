#pragma kernel Init
#pragma kernel Emit
#pragma kernel Update
#pragma kernel GetDividable
#pragma kernel Divide

#define SIMULATION_BLOCK_SIZE 128
#include "Particle.cginc"
#include "../../Common/Libs/Random.cginc"

StructuredBuffer<Particle> _ParticlesRead;
RWStructuredBuffer<Particle> _Particles;
AppendStructuredBuffer<uint> _ParticlePoolAppend;
ConsumeStructuredBuffer<uint> _ParticlePoolConsume;

AppendStructuredBuffer<uint> _DividablePoolAppend;
ConsumeStructuredBuffer<uint> _DividablePoolConsume;

float _Time;
float _DT;

float _Grow;
float _Drag;
float _Limit;
float _Repulsion;

float2 _EmitPoint;
int _EmitCount;

int _DivideCount;

Particle create() {
	Particle p;
	p.position = (float2)0;
	p.velocity = (float2)0;
	p.radius = p.threshold = 1;
	p.links = 0;
	p.alive = true;
	return p;
}

bool is_dividable_particle(Particle p, uint idx) {
	float rate = p.radius / p.threshold;
	return rate > 0.95f;

	// random divide
	// return nrand(float2(idx, _Time)) < 0.1f;
}

uint divide_particle(uint idx, float2 offset) {

	Particle parent = _Particles[idx];
	Particle child = create();

	// half parent and child's radius
	float hr = parent.radius * 0.5f;
	hr = max(hr, 0.1f);
	parent.radius = child.radius = hr;

	// displace parent and child's positions
	float2 center = parent.position;
	parent.position = center - offset;
	child.position = center + offset;

	// set child max radius
	float x = nrand(float2(_Time, idx));
	child.threshold = hr * lerp(1.25, 2.0, x);

	// set child index from particle pool
	uint cidx = _ParticlePoolConsume.Consume();
	_Particles[cidx] = child;
	
	// update parent
	_Particles[idx] = parent;

	return cidx;
}


uint divide_particle(uint idx) {
	Particle parent = _Particles[idx];

	float2 offset = random_point_on_circle(float2(idx, _Time)) *
					parent.radius * 0.25f;

	Particle child = create();

	// half parent and child's radius
	float hr = parent.radius * 0.5f;
	hr = max(hr, 0.1f);
	parent.radius = child.radius = hr;

	// displace parent and child's positions
	float2 center = parent.position;
	parent.position = center - offset;
	child.position = center + offset;

	// set child max radius
	float x = nrand(float2(_Time, idx));
	child.threshold = hr * lerp(1.25, 2.0, x);

	// set child index from particle pool
	uint cidx = _ParticlePoolConsume.Consume();
	_Particles[cidx] = child;

	// update parent
	_Particles[idx] = parent;

	return cidx;
}

[numthreads(SIMULATION_BLOCK_SIZE,1,1)]
void Init (uint3 id : SV_DispatchThreadID)
{
	uint idx = id.x;

	uint count, stride;
	_Particles.GetDimensions(count, stride);
	if (idx > count)
		return;

	Particle p = create();
	p.alive = false;
	_Particles[idx] = p;

	_ParticlePoolAppend.Append(idx);
}

[numthreads(SIMULATION_BLOCK_SIZE, 1, 1)]
void Emit(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= (uint)_EmitCount)
		return;

	uint idx = _ParticlePoolConsume.Consume();

	Particle p = create();

	float2 offset = random_point_on_circle(id.xx + float2(0, _Time));
	p.position = _EmitPoint.xy + offset;
	p.radius = nrand(id.xx + float2(_Time, 0));

	_Particles[idx] = p;
}

[numthreads(SIMULATION_BLOCK_SIZE, 1, 1)]
void Update(uint3 id : SV_DispatchThreadID) 
{
	uint idx = id.x;

	uint count, stride;
	_ParticlesRead.GetDimensions(count, stride);
	if (idx > count)
		return;

	Particle p = _ParticlesRead[idx];

	if (p.alive) {
		// Grow
		p.radius = min(p.threshold, p.radius + _DT * _Grow * p.radius);

		// Repulsion
		for (uint i = 0; i < count; i++) {
			Particle other = _ParticlesRead[i];

			if (i == idx || !other.alive) 
				continue;

			float2 dir = p.position - other.position;
			float l = length(dir);
			float r = (p.radius + other.radius) * _Repulsion;
			if (l < r) {
				dir += random_point_on_circle(p.position + float2(i, idx)) * step(l, 0.0001);
				p.velocity += normalize(dir) * (r - l);
			}
		}

		float vl = length(p.velocity);
		if (vl > 0) {
			p.position += normalize(p.velocity) * min(vl, _Limit) * _DT;
			p.velocity =  normalize(p.velocity) * min(vl * _Drag, _Limit);
		}
		else {
			p.velocity = (float2)0;
		}
	}
	_Particles[idx] = p;
}

[numthreads(SIMULATION_BLOCK_SIZE, 1, 1)]
void GetDividable(uint3 id : SV_DispatchThreadID)
{
	uint idx = id.x;

	uint count, stride;
	_Particles.GetDimensions(count, stride);
	if (idx > count)
		return;

	Particle p = _Particles[idx];

	if (p.alive && is_dividable_particle(p, idx)) {
		_DividablePoolAppend.Append(idx);
	}
}

[numthreads(SIMULATION_BLOCK_SIZE, 1, 1)]
void Divide(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= _DivideCount)
		return;

	uint idx = _DividablePoolConsume.Consume();
	divide_particle(idx);
}



//groupshared Particle sharedParticles[SIMULATION_BLOCK_SIZE];
//
//[numthreads(SIMULATION_BLOCK_SIZE, 1, 1)]
//void Update(uint3 id : SV_DispatchThreadID, uint GI : SV_GroupIndex)
//{
//	uint idx = id.x;
//
//	uint count, stride;
//	_ParticlesRead.GetDimensions(count, stride);
//
//	Particle p = _ParticlesRead[idx];
//
//	// Grow
//	if(p.alive)
//		p.radius = min(p.threshold, p.radius + _DT * _Grow * p.radius);
//
//	// Repulsion
//	[loop]
//	for (uint N_block_ID = 0; N_block_ID < (uint)count; N_block_ID += SIMULATION_BLOCK_SIZE) {
//
//		sharedParticles[GI] = _ParticlesRead[N_block_ID + GI];
//
//		GroupMemoryBarrierWithGroupSync();
//
//		for (int N_tile_ID = 0; N_tile_ID < SIMULATION_BLOCK_SIZE; N_tile_ID++) {
//			Particle other = sharedParticles[N_tile_ID];
//
//			if (!p.alive || !other.alive || N_block_ID + N_tile_ID == idx)
//				continue;
//
//			float2 dir = p.position - other.position;
//			float l = length(dir);
//			float r = (p.radius + other.radius) * _Repulsion;
//			if (l < r) {
//				dir += random_point_on_circle(p.position + float2(N_tile_ID, idx)) * step(l, 0.0001);
//				p.velocity += normalize(dir) * (r - l);
//			}
//		}
//		GroupMemoryBarrierWithGroupSync();
//	}
//
//	float vl = length(p.velocity);
//	if (vl > 0) {
//		p.position += normalize(p.velocity) * min(vl, _Limit) * _DT;
//		p.velocity = normalize(p.velocity) * min(vl * _Drag, _Limit);
//	}
//	else {
//		p.velocity = (float2)0;
//	}
//
//	_Particles[idx] = p;
//}