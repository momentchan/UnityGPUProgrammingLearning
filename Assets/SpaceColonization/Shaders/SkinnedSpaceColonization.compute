#pragma kernel SetupSkin
#pragma kernel SetupAttractions
#pragma kernel SetupNodes
#pragma kernel Seed
#pragma kernel Search
#pragma kernel Attract
#pragma kernel Connect
#pragma kernel Remove
#pragma kernel Grow
#pragma kernel Animate
#define THREAD [numthreads(128, 1, 1)]

#include "../../Common/Libs/Random.cginc"
#include "Includes/SkinnedNode.cginc"
#include "Includes/SkinnedAttraction.cginc"
#include "Includes/SkinnedCandidate.cginc"
#include "Includes/Edge.cginc"

RWStructuredBuffer<SkinnedNode> _Nodes;

AppendStructuredBuffer<uint> _NodesPoolAppend;
ConsumeStructuredBuffer<uint> _NodesPoolConsume;

AppendStructuredBuffer<SkinnedCandidate> _CandidatesAppend;
ConsumeStructuredBuffer<SkinnedCandidate> _CandidatesConsume;

AppendStructuredBuffer<Edge> _EdgesAppend;
ConsumeStructuredBuffer<Edge> _EdgesConsume;

StructuredBuffer<float3> _Vertices;
StructuredBuffer<int> _Bones;

RWStructuredBuffer<SkinnedAttraction> _Attractions;
StructuredBuffer<float3> _Seeds;

StructuredBuffer<float4x4> _BindPoses;
StructuredBuffer<float4x4> _BoneMatrices;

float _MassMin;
float _MassMax;
float _InfluenceDistance;
float _GrowthDistance;
float _KillDistance;
float _DT;
int _ConnectCount;

uint CreateNodeAndGetIdFromPool(out SkinnedNode node) {
	uint i = _NodesPoolConsume.Consume();
	node.position = node.animated = float3(0, 0, 0);
	node.index0 = -1;
	node.t = 0;
	node.offset = 0;
	node.from = -1;
	node.mass = 0;
	node.active = true;
	return i;
}

void CreateEdge(int a, int b) {
	Edge e;
	e.a = a;
	e.b = b;
	_EdgesAppend.Append(e);
}

THREAD
void SetupSkin(uint3 id : SV_DispatchThreadID)
{
	uint idx = id.x;
	uint count, stride;
	_Attractions.GetDimensions(count, stride);
	if (idx >= count)
		return;

	SkinnedAttraction attr = _Attractions[idx];

	_Vertices.GetDimensions(count, stride);
	float3 p = attr.position;
	float min_dist = 1e08;
	for (int i = 0; i < count; i++) {
		float3 v = _Vertices[i];
		float d = distance(p, v);
		if (d < min_dist) {
			min_dist = d;
			attr.bone = _Bones[i];
		}
	}
	_Attractions[idx] = attr;
}

THREAD
void SetupAttractions(uint3 id : SV_DispatchThreadID)
{
	uint idx = id.x;
	uint count, stride;
	_Attractions.GetDimensions(count, stride);
	if (idx >= count)
		return;

	SkinnedAttraction attr = _Attractions[idx];
	attr.active = true;
	attr.found = false;
	attr.nearestIndex = -1;
	_Attractions[idx] = attr;
}

THREAD
void SetupNodes(uint3 id : SV_DispatchThreadID)
{
	uint idx = id.x;
	uint count, stride;
	_Nodes.GetDimensions(count, stride);
	if (idx >= count)
		return;

	_NodesPoolAppend.Append(idx);

	SkinnedNode n = _Nodes[idx];
	n.index0 = -1;
	n.active = false;
	_Nodes[idx] = n;
}

THREAD
void Seed(uint3 id : SV_DispatchThreadID)
{
	uint idx = id.x;
	uint count, stride;
	_Seeds.GetDimensions(count, stride);
	if (idx >= count)
		return;

	SkinnedNode n;
	uint i = CreateNodeAndGetIdFromPool(n);
	n.position = n.animated =  _Seeds[idx];
	n.t = 1;
	n.offset = 0;
	n.from = -1;
	n.mass = lerp(_MassMin, _MassMax, nrand(float2(1.0 * idx / count, 0)));

	_Attractions.GetDimensions(count, stride);
	float3 p = n.position;
	float min_dist = 1e08;
	for (int j = 0; j < count; j++) {
		SkinnedAttraction attr = _Attractions[j];

		float3 v = attr.position;
		float d = distance(p, v);
		if (d < min_dist) {
			min_dist = d;
			n.index0 = attr.bone;
		}
	}

	_Nodes[i] = n;
}

THREAD
void Search(uint3 id : SV_DispatchThreadID)
{
	uint idx = id.x;
	uint count, stride;
	_Attractions.GetDimensions(count, stride);
	if (idx >= count)
		return;

	SkinnedAttraction attr = _Attractions[idx];
	attr.found = false;
	if (attr.active) {
		_Nodes.GetDimensions(count, stride);

		float min_dist = _InfluenceDistance;
		uint nearest = -1;

		for (uint i = 0; i < count; i++) {
			SkinnedNode n = _Nodes[i];

			if (n.active) {
				float3 dir = attr.position - n.position;
				float dist = length(dir);
				if (dist < min_dist) {
					min_dist = dist;
					nearest = i;
					attr.found = true;
					attr.nearestIndex = nearest;
				}
			}
		}
	}
	_Attractions[idx] = attr;
}

THREAD
void Attract(uint3 id : SV_DispatchThreadID)
{
	uint idx = id.x;
	uint count, stride;
	_Nodes.GetDimensions(count, stride);
	if (idx >= count)
		return;

	SkinnedNode n = _Nodes[idx];
	if (n.active && n.t >= 1.0) {

		float3 dir = 0;
		uint counter = 0;
		float min_dist = 1e08;

		_Attractions.GetDimensions(count, stride);
		for (uint i = 0; i < count; i++) {
			SkinnedAttraction attr = _Attractions[i];

			if (attr.active && attr.found && attr.nearestIndex == idx) {

				float3 dir2 = attr.position - n.position;
				dir += normalize(dir2);
				counter++;

				float d = length(dir2);
				if (d < min_dist) {
					min_dist = d;
					n.index0 = attr.bone;
				}
			}
		}

		if (counter > 0) {
			dir /= counter;

			SkinnedCandidate c;
			c.position = n.position + dir * _GrowthDistance;
			c.node = idx;
			c.bone = n.index0;
			_CandidatesAppend.Append(c);
		}
	}
}

THREAD
void Connect(uint3 id : SV_DispatchThreadID)
{
	uint idx = id.x;
	if (idx >= _ConnectCount)
		return;

	SkinnedCandidate c = _CandidatesConsume.Consume();

	uint idx1 = c.node;
	SkinnedNode n1 = _Nodes[idx1];
	SkinnedNode n2;
	uint idx2 = CreateNodeAndGetIdFromPool(n2);
	n2.position = c.position;
	n2.animated = c.position;
	n2.index0 = c.bone;
	n2.offset = n1.offset + 1.0;
	n2.from = idx1;
	n2.mass = lerp(_MassMin, _MassMax, nrand(float2(idx1, idx2)));

	_Nodes[idx2] = n2;

	CreateEdge(idx1, idx2);
}

THREAD
void Remove(uint3 id : SV_DispatchThreadID)
{
	uint idx = id.x;
	uint count, stride;
	_Attractions.GetDimensions(count, stride);
	if (idx >= count)
		return;

	SkinnedAttraction attr = _Attractions[idx];
	if (!attr.active)
		return;

	_Nodes.GetDimensions(count, stride);
	for (uint i = 0; i < count; i++) {
		SkinnedNode n = _Nodes[i];
		if (n.active) {
			float d = distance(attr.position, n.position);
			if (d < _KillDistance) {
				attr.active = false;
				_Attractions[idx] = attr;
				return;
			}
		}
	}
}

THREAD
void Grow(uint3 id : SV_DispatchThreadID)
{
	uint idx = id.x;
	uint count, stride;
	_Nodes.GetDimensions(count, stride);
	if (idx >= count)
		return;

	SkinnedNode n = _Nodes[idx];
	if (n.active) {
		n.t = saturate(n.t + _DT * n.mass);
		_Nodes[idx] = n;
	}
}

THREAD
void Animate(uint3 id : SV_DispatchThreadID)
{
	uint idx = id.x;
	uint count, stride;
	_Nodes.GetDimensions(count, stride);
	if (idx >= count)
		return;

	SkinnedNode node = _Nodes[idx];
	if (node.active) {
		float4x4 bind = _BindPoses[node.index0];
		float4x4 m = _BoneMatrices[node.index0];

		node.animated = mul(mul(m, bind), float4(node.position, 1)).xyz;
		_Nodes[idx] = node;
	}
}